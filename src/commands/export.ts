import * as p from '@clack/prompts';
import { resolve, join, basename } from 'path';
import { existsSync, readFileSync, writeFileSync, createWriteStream, readdirSync, statSync } from 'fs';
import { execSync } from 'child_process';
import { isInitialized, getConfigDir, getHistoryDir, loadConfig } from '../lib/config.js';
import { getAllSnapshots } from '../lib/history.js';
import { getPlanProgress } from '../lib/plan.js';

interface ExportOptions {
  output?: string;
}

/**
 * Create a zip file without external dependencies
 * Uses native zip command on macOS/Linux, PowerShell on Windows
 */
function createZip(sourceDir: string, outputPath: string): boolean {
  try {
    const platform = process.platform;
    if (platform === 'win32') {
      // PowerShell Compress-Archive
      execSync(`powershell -command "Compress-Archive -Path '${sourceDir}/*' -DestinationPath '${outputPath}'"`, {
        stdio: 'pipe',
      });
    } else {
      // Unix zip command
      execSync(`cd "${sourceDir}" && zip -r "${outputPath}" .`, {
        stdio: 'pipe',
      });
    }
    return true;
  } catch {
    return false;
  }
}

/**
 * Generate metadata markdown file
 */
function generateMetadataMarkdown(
  projectPath: string,
  snapshots: ReturnType<typeof getAllSnapshots>,
  planProgress: ReturnType<typeof getPlanProgress>,
  config: ReturnType<typeof loadConfig>
): string {
  const answers = planProgress?.answers || {};
  const projectName = answers.projectName || basename(projectPath);

  // Timeline info
  const firstSnapshot = snapshots[0];
  const lastSnapshot = snapshots[snapshots.length - 1];
  const startDate = firstSnapshot?.timestamp || 'N/A';
  const lastDate = lastSnapshot?.timestamp || 'N/A';

  // Git info from last snapshot
  const gitInfo = lastSnapshot?.git;

  // All unique files across snapshots
  const allFiles = new Set<string>();
  for (const snapshot of snapshots) {
    for (const file of snapshot.files) {
      allFiles.add(file);
    }
  }

  // Parse features
  const features = answers.coreFeatures
    ? answers.coreFeatures
        .split(/[,;\n]/)
        .map((f: string) => f.trim())
        .filter((f: string) => f)
        .map((f: string) => `- ${f}`)
        .join('\n')
    : 'Not specified';

  let md = `# ${projectName}

> Exported from pmpt-cli

## Project Overview

**Product Idea:**
${answers.productIdea || 'Not specified'}

${answers.additionalContext ? `**Additional Context:**\n${answers.additionalContext}\n` : ''}
**Key Features:**
${features}

**Tech Stack:**
${answers.techStack || 'Not specified'}

---

## Export Information

| Item | Value |
|------|-------|
| Total Iterations | ${snapshots.length} |
| First Version | ${startDate} |
| Last Version | ${lastDate} |
| Files Tracked | ${allFiles.size} |
`;

  if (gitInfo) {
    md += `| Git Branch | ${gitInfo.branch} |
| Last Commit | ${gitInfo.commit} |
`;
  }

  md += `
---

## Version Timeline

| Version | Date | Files | Git |
|---------|------|-------|-----|
`;

  for (const snapshot of snapshots) {
    const gitCol = snapshot.git
      ? `${snapshot.git.commit}${snapshot.git.dirty ? ' (dirty)' : ''}`
      : '-';
    md += `| v${snapshot.version} | ${snapshot.timestamp} | ${snapshot.files.length} | ${gitCol} |\n`;
  }

  md += `
---

## File List

`;

  for (const file of Array.from(allFiles).sort()) {
    md += `- ${file}\n`;
  }

  md += `
---

*Generated by [pmpt-cli](https://pmptwiki.com)*
`;

  return md;
}

export async function cmdExport(path?: string, options?: ExportOptions): Promise<void> {
  const projectPath = path ? resolve(path) : process.cwd();

  if (!isInitialized(projectPath)) {
    p.log.error('Project not initialized. Run `pmpt init` first.');
    process.exit(1);
  }

  p.intro('pmpt export');

  const config = loadConfig(projectPath);
  const snapshots = getAllSnapshots(projectPath);
  const planProgress = getPlanProgress(projectPath);

  if (snapshots.length === 0) {
    p.log.warn('No snapshots found.');
    p.log.info('Run `pmpt save` or `pmpt plan` first to create versions.');
    p.outro('');
    return;
  }

  const projectName = planProgress?.answers?.projectName || basename(projectPath);
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 10);
  const exportName = `pmpt-export-${projectName}-${timestamp}`;

  // Output path
  const outputPath = options?.output
    ? resolve(options.output)
    : resolve(projectPath, `${exportName}.zip`);

  const s = p.spinner();
  s.start('Preparing export...');

  // Create temp directory for export
  const tempDir = join(projectPath, '.pmpt', '.export-temp');
  execSync(`rm -rf "${tempDir}" && mkdir -p "${tempDir}"`, { stdio: 'pipe' });

  // Copy history folder
  const historyDir = getHistoryDir(projectPath);
  execSync(`cp -r "${historyDir}" "${tempDir}/history"`, { stdio: 'pipe' });

  // Generate and save metadata
  const metadataContent = generateMetadataMarkdown(projectPath, snapshots, planProgress, config);
  writeFileSync(join(tempDir, 'README.md'), metadataContent, 'utf-8');

  // Copy current docs if exists
  const docsDir = join(getConfigDir(projectPath), 'docs');
  if (existsSync(docsDir)) {
    execSync(`cp -r "${docsDir}" "${tempDir}/docs"`, { stdio: 'pipe' });
  }

  // Copy config (without sensitive data)
  if (config) {
    const exportConfig = {
      projectPath: basename(projectPath),
      docsPath: config.docsPath,
      createdAt: config.createdAt,
      trackGit: config.trackGit,
    };
    writeFileSync(join(tempDir, 'config.json'), JSON.stringify(exportConfig, null, 2), 'utf-8');
  }

  // Copy plan progress if exists
  if (planProgress) {
    writeFileSync(join(tempDir, 'plan.json'), JSON.stringify(planProgress, null, 2), 'utf-8');
  }

  s.message('Creating archive...');

  // Create zip
  const zipSuccess = createZip(tempDir, outputPath);

  // Cleanup temp directory
  execSync(`rm -rf "${tempDir}"`, { stdio: 'pipe' });

  if (!zipSuccess) {
    s.stop('Export failed');
    p.log.error('Failed to create zip archive.');
    p.log.info('Make sure `zip` command is available on your system.');
    process.exit(1);
  }

  s.stop('Export complete!');

  // Summary
  const fileSizeBytes = statSync(outputPath).size;
  const fileSize = fileSizeBytes < 1024
    ? `${fileSizeBytes} B`
    : fileSizeBytes < 1024 * 1024
      ? `${(fileSizeBytes / 1024).toFixed(1)} KB`
      : `${(fileSizeBytes / 1024 / 1024).toFixed(1)} MB`;

  const summary = [
    `Project: ${projectName}`,
    `Versions: ${snapshots.length}`,
    `Size: ${fileSize}`,
    '',
    `Output: ${outputPath}`,
  ];

  p.note(summary.join('\n'), 'Export Summary');

  p.log.info('Share this file to let others reproduce your AI development journey!');
  p.outro('');
}
