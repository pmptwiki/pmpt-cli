import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { getConfigDir, getHistoryDir } from './config.js';
import { getGitInfo, isGitRepo } from './git.js';
import { loadConfig } from './config.js';

export interface PlanPhase {
  id: number;
  name: string;
  nameEn: string;
  description: string;
  questions: PlanQuestion[];
  template: (answers: Record<string, string>) => string;
}

export interface PlanQuestion {
  key: string;
  question: string;
  placeholder?: string;
  multiline?: boolean;
  required?: boolean;
}

export interface PlanProgress {
  currentPhase: number;
  completedPhases: number[];
  startedAt: string;
  updatedAt: string;
  projectName?: string;
}

const PLAN_FILE = 'plan-progress.json';

export const PHASES: PlanPhase[] = [
  {
    id: 1,
    name: '아이디어 & 문제 정의',
    nameEn: 'idea',
    description: '어떤 문제를 해결하려고 하나요?',
    questions: [
      { key: 'projectName', question: '프로젝트 이름은 무엇인가요?', placeholder: 'my-awesome-app', required: true },
      { key: 'problem', question: '해결하려는 문제는 무엇인가요?', placeholder: '사용자들이 ~하는데 어려움을 겪고 있다', multiline: true, required: true },
      { key: 'solution', question: '이 문제를 어떻게 해결할 건가요?', placeholder: '~하는 도구/서비스를 만들어서', multiline: true, required: true },
      { key: 'uniqueness', question: '기존 솔루션과 다른 점은 무엇인가요?', placeholder: '기존에는 ~했지만, 우리는 ~', multiline: true },
    ],
    template: (a) => `# ${a.projectName} - 아이디어 정의

## 해결하려는 문제

${a.problem}

## 제안하는 해결책

${a.solution}

## 차별점

${a.uniqueness || '(아직 정의되지 않음)'}

---
*Generated by PromptWiki Plan - Phase 1*
`,
  },
  {
    id: 2,
    name: '타겟 사용자 정의',
    nameEn: 'users',
    description: '누구를 위한 제품인가요?',
    questions: [
      { key: 'targetUser', question: '주요 타겟 사용자는 누구인가요?', placeholder: '예: 스타트업 개발자, 대학생, 소상공인', required: true },
      { key: 'userPain', question: '타겟 사용자가 현재 겪고 있는 가장 큰 불편함은?', multiline: true, required: true },
      { key: 'userGoal', question: '타겟 사용자가 궁극적으로 달성하고 싶은 것은?', multiline: true },
      { key: 'userJourney', question: '사용자가 이 제품을 어떻게 발견하고 사용하게 될까요?', multiline: true },
    ],
    template: (a) => `# 타겟 사용자 정의

## 주요 타겟

${a.targetUser}

## 사용자 페인포인트

${a.userPain}

## 사용자 목표

${a.userGoal || '(아직 정의되지 않음)'}

## 사용자 여정

${a.userJourney || '(아직 정의되지 않음)'}

---
*Generated by PromptWiki Plan - Phase 2*
`,
  },
  {
    id: 3,
    name: '핵심 기능 명세',
    nameEn: 'features',
    description: '어떤 기능으로 문제를 해결하나요?',
    questions: [
      { key: 'coreFeature', question: '가장 핵심이 되는 기능 하나는 무엇인가요?', placeholder: '예: 실시간 협업 에디터', required: true },
      { key: 'featureList', question: '필요한 기능들을 나열해주세요 (줄바꿈으로 구분)', multiline: true, required: true },
      { key: 'mustHave', question: '반드시 있어야 하는 기능은? (MVP 필수)', multiline: true, required: true },
      { key: 'niceToHave', question: '있으면 좋지만 나중에 추가할 기능은?', multiline: true },
    ],
    template: (a) => `# 기능 명세

## 핵심 기능

**${a.coreFeature}**

## 전체 기능 목록

${a.featureList.split('\n').map((f: string) => `- ${f.trim()}`).filter((f: string) => f !== '- ').join('\n')}

## MVP 필수 기능

${a.mustHave.split('\n').map((f: string) => `- [ ] ${f.trim()}`).filter((f: string) => f !== '- [ ] ').join('\n')}

## 추후 추가 기능

${a.niceToHave ? a.niceToHave.split('\n').map((f: string) => `- [ ] ${f.trim()}`).filter((f: string) => f !== '- [ ] ').join('\n') : '(아직 정의되지 않음)'}

---
*Generated by PromptWiki Plan - Phase 3*
`,
  },
  {
    id: 4,
    name: '기술 스택 설계',
    nameEn: 'tech',
    description: '어떤 기술로 만들 건가요?',
    questions: [
      { key: 'frontend', question: '프론트엔드 기술은? (웹앱이 아니면 "해당없음")', placeholder: 'React, Vue, Next.js 등' },
      { key: 'backend', question: '백엔드/서버 기술은?', placeholder: 'Node.js, Python, Go 등' },
      { key: 'database', question: '데이터베이스는?', placeholder: 'PostgreSQL, MongoDB, Supabase 등' },
      { key: 'hosting', question: '호스팅/배포 방식은?', placeholder: 'Vercel, AWS, 자체 서버 등' },
      { key: 'techReason', question: '이 기술들을 선택한 이유는?', multiline: true },
    ],
    template: (a) => `# 기술 스택

## 스택 구성

| 영역 | 기술 |
|------|------|
| Frontend | ${a.frontend || '해당없음'} |
| Backend | ${a.backend || '해당없음'} |
| Database | ${a.database || '해당없음'} |
| Hosting | ${a.hosting || '미정'} |

## 선택 이유

${a.techReason || '(아직 정의되지 않음)'}

---
*Generated by PromptWiki Plan - Phase 4*
`,
  },
  {
    id: 5,
    name: 'MVP 범위 정의',
    nameEn: 'mvp',
    description: '최소 기능 제품의 범위를 정합니다',
    questions: [
      { key: 'mvpGoal', question: 'MVP로 검증하고 싶은 가설은?', placeholder: '사용자들이 ~하면 ~할 것이다', required: true },
      { key: 'mvpFeatures', question: 'MVP에 포함될 기능들 (최소한으로)', multiline: true, required: true },
      { key: 'mvpExclude', question: 'MVP에서 제외할 것들', multiline: true },
      { key: 'successMetric', question: 'MVP 성공 지표는? (숫자로)', placeholder: '예: DAU 100명, 전환율 5%' },
    ],
    template: (a) => `# MVP 정의

## 검증할 가설

> ${a.mvpGoal}

## MVP 포함 기능

${a.mvpFeatures.split('\n').map((f: string) => `- [ ] ${f.trim()}`).filter((f: string) => f !== '- [ ] ').join('\n')}

## MVP 제외 사항

${a.mvpExclude ? a.mvpExclude.split('\n').map((f: string) => `- ${f.trim()}`).filter((f: string) => f !== '- ').join('\n') : '(없음)'}

## 성공 지표

${a.successMetric || '(아직 정의되지 않음)'}

---
*Generated by PromptWiki Plan - Phase 5*
`,
  },
  {
    id: 6,
    name: '구현 계획',
    nameEn: 'plan',
    description: '어떤 순서로 만들 건가요?',
    questions: [
      { key: 'milestones', question: '주요 마일스톤을 나열해주세요', multiline: true, required: true },
      { key: 'firstWeek', question: '첫 1주일 동안 할 일은?', multiline: true, required: true },
      { key: 'blockers', question: '예상되는 어려움/장애물은?', multiline: true },
      { key: 'resources', question: '필요한 리소스(인력, 비용, 도구)는?', multiline: true },
    ],
    template: (a) => `# 구현 계획

## 마일스톤

${a.milestones.split('\n').map((m: string, i: number) => `${i + 1}. ${m.trim()}`).filter((m: string) => !m.endsWith('. ')).join('\n')}

## 첫 1주일 할 일

${a.firstWeek.split('\n').map((t: string) => `- [ ] ${t.trim()}`).filter((t: string) => t !== '- [ ] ').join('\n')}

## 예상 장애물

${a.blockers ? a.blockers.split('\n').map((b: string) => `- ⚠️ ${b.trim()}`).filter((b: string) => b !== '- ⚠️ ').join('\n') : '(없음)'}

## 필요 리소스

${a.resources || '(아직 정의되지 않음)'}

---
*Generated by PromptWiki Plan - Phase 6*
`,
  },
];

export function getPlanProgress(projectPath: string): PlanProgress | null {
  const planPath = join(getConfigDir(projectPath), PLAN_FILE);
  if (!existsSync(planPath)) return null;
  try {
    return JSON.parse(readFileSync(planPath, 'utf-8'));
  } catch {
    return null;
  }
}

export function savePlanProgress(projectPath: string, progress: PlanProgress): void {
  const configDir = getConfigDir(projectPath);
  mkdirSync(configDir, { recursive: true });
  const planPath = join(configDir, PLAN_FILE);
  progress.updatedAt = new Date().toISOString();
  writeFileSync(planPath, JSON.stringify(progress, null, 2), 'utf-8');
}

export function initPlanProgress(projectPath: string): PlanProgress {
  const progress: PlanProgress = {
    currentPhase: 1,
    completedPhases: [],
    startedAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };
  savePlanProgress(projectPath, progress);
  return progress;
}

export function savePhaseDocument(
  projectPath: string,
  phase: PlanPhase,
  answers: Record<string, string>
): string {
  const historyDir = getHistoryDir(projectPath);
  mkdirSync(historyDir, { recursive: true });

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  const fileName = `phase-${phase.id}-${phase.nameEn}-v1-${timestamp}.md`;
  const filePath = join(historyDir, fileName);

  const content = phase.template(answers);
  writeFileSync(filePath, content, 'utf-8');

  // Git 메타데이터 저장
  const config = loadConfig(projectPath);
  if (config?.trackGit && isGitRepo(projectPath)) {
    const gitInfo = getGitInfo(projectPath, config.repo);
    if (gitInfo) {
      const metaPath = filePath.replace(/\.md$/, '.meta.json');
      writeFileSync(metaPath, JSON.stringify({
        version: 1,
        phase: phase.id,
        phaseName: phase.name,
        timestamp,
        git: {
          commit: gitInfo.commit,
          commitFull: gitInfo.commitFull,
          branch: gitInfo.branch,
          dirty: gitInfo.dirty,
          tag: gitInfo.tag,
        },
      }, null, 2), 'utf-8');
    }
  }

  return filePath;
}

export function getCompletionSummary(progress: PlanProgress): string {
  const total = PHASES.length;
  const completed = progress.completedPhases.length;
  const percentage = Math.round((completed / total) * 100);

  const bar = '█'.repeat(completed) + '░'.repeat(total - completed);
  return `[${bar}] ${completed}/${total} (${percentage}%)`;
}
