import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { getConfigDir, getPmptDir } from './config.js';
import { createFullSnapshot } from './history.js';

export interface PlanQuestion {
  key: string;
  question: string;
  placeholder?: string;
  multiline?: boolean;
  required?: boolean;
}

export interface PlanProgress {
  completed: boolean;
  startedAt: string;
  updatedAt: string;
  answers?: Record<string, string>;
}

const PLAN_FILE = 'plan-progress.json';

// 6 simple questions (answer in any language you prefer)
export const PLAN_QUESTIONS: PlanQuestion[] = [
  {
    key: 'projectName',
    question: 'Project name?',
    placeholder: 'my-awesome-app',
    required: true,
  },
  {
    key: 'problem',
    question: 'What problem are you solving?',
    placeholder: 'e.g., Developers spend too much time finding API docs',
    multiline: true,
    required: true,
  },
  {
    key: 'solution',
    question: 'How will you solve it?',
    placeholder: 'e.g., AI analyzes code and auto-generates API docs',
    multiline: true,
    required: true,
  },
  {
    key: 'targetUser',
    question: 'Who is your target user?',
    placeholder: 'e.g., Startup backend developers',
    required: true,
  },
  {
    key: 'coreFeatures',
    question: 'Core features for MVP? (one per line)',
    placeholder: 'e.g.:\nCode upload\nAI analysis\nDoc generation',
    multiline: true,
    required: true,
  },
  {
    key: 'techStack',
    question: 'Preferred tech stack? (optional)',
    placeholder: 'e.g., React, Node.js, PostgreSQL',
    multiline: false,
    required: false,
  },
];

// Generate AI prompt (language-agnostic template)
export function generateAIPrompt(answers: Record<string, string>): string {
  const features = answers.coreFeatures
    .split('\n')
    .map((f: string) => f.trim())
    .filter((f: string) => f)
    .map((f: string) => `- ${f}`)
    .join('\n');

  const techSection = answers.techStack
    ? `\n## Tech Stack Preferences\n${answers.techStack}\n`
    : '';

  return `# ${answers.projectName} â€” Product Development Request

## Problem
${answers.problem}

## Proposed Solution
${answers.solution}

## Target User
${answers.targetUser}

## MVP Core Features
${features}
${techSection}
---

Please help me build this product based on the requirements above.

1. First, review the requirements and ask if anything is unclear.
2. Propose a technical architecture.
3. Outline the MVP implementation steps.
4. Start coding from the first step.

I'll confirm progress at each step before moving to the next.

## Documentation Rule

**Important:** Update this document (located at \`.promptwiki/pmpt/pmpt.md\`) at these moments:
- When architecture or tech decisions are finalized
- When a feature is implemented (mark as done)
- When a development phase is completed
- When requirements change or new decisions are made

Add a "## Progress" section below and keep it updated:
\`\`\`
## Progress
- [x] Completed item
- [ ] Pending item
\`\`\`

This keeps a living record of our development journey.
`;
}

// Generate plan document
export function generatePlanDocument(answers: Record<string, string>): string {
  const features = answers.coreFeatures
    .split('\n')
    .map((f: string) => f.trim())
    .filter((f: string) => f)
    .map((f: string) => `- [ ] ${f}`)
    .join('\n');

  const techSection = answers.techStack
    ? `\n## Tech Stack\n${answers.techStack}\n`
    : '';

  return `# ${answers.projectName}

## Problem
${answers.problem}

## Solution
${answers.solution}

## Target User
${answers.targetUser}

## MVP Features
${features}
${techSection}
---
*Generated by PromptWiki Plan*
`;
}

export function getPlanProgress(projectPath: string): PlanProgress | null {
  const planPath = join(getConfigDir(projectPath), PLAN_FILE);
  if (!existsSync(planPath)) return null;
  try {
    return JSON.parse(readFileSync(planPath, 'utf-8'));
  } catch {
    return null;
  }
}

export function savePlanProgress(projectPath: string, progress: PlanProgress): void {
  const configDir = getConfigDir(projectPath);
  mkdirSync(configDir, { recursive: true });
  const planPath = join(configDir, PLAN_FILE);
  progress.updatedAt = new Date().toISOString();
  writeFileSync(planPath, JSON.stringify(progress, null, 2), 'utf-8');
}

export function initPlanProgress(projectPath: string): PlanProgress {
  const progress: PlanProgress = {
    completed: false,
    startedAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };
  savePlanProgress(projectPath, progress);
  return progress;
}

export interface SavePlanResult {
  planPath: string;
  promptPath: string;
}

export function savePlanDocuments(
  projectPath: string,
  answers: Record<string, string>
): SavePlanResult {
  const pmptDir = getPmptDir(projectPath);
  mkdirSync(pmptDir, { recursive: true });

  // Save plan to pmpt folder
  const planPath = join(pmptDir, 'plan.md');
  const planContent = generatePlanDocument(answers);
  writeFileSync(planPath, planContent, 'utf-8');

  // Save AI prompt to pmpt folder
  const promptPath = join(pmptDir, 'pmpt.md');
  const promptContent = generateAIPrompt(answers);
  writeFileSync(promptPath, promptContent, 'utf-8');

  // Create initial snapshot
  createFullSnapshot(projectPath);

  return { planPath, promptPath };
}
