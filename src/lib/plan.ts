import { existsSync, readFileSync, writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { getConfigDir, getPmptDir } from './config.js';
import { createFullSnapshot } from './history.js';

export interface PlanQuestion {
  key: string;
  question: string;
  placeholder?: string;
  multiline?: boolean;
  required?: boolean;
}

export interface PlanProgress {
  completed: boolean;
  startedAt: string;
  updatedAt: string;
  answers?: Record<string, string>;
}

const PLAN_FILE = 'plan-progress.json';

// 5 simple questions (answer in any language you prefer)
// This is the first step of your product journey with AI!
export const PLAN_QUESTIONS: PlanQuestion[] = [
  {
    key: 'projectName',
    question: 'What should we call your project?',
    placeholder: 'my-awesome-app',
    required: true,
  },
  {
    key: 'productIdea',
    question: "What would you like to build with AI? (Let's start your journey!)",
    placeholder: 'e.g., A Chrome extension that summarizes long articles, A budget tracking app for freelancers',
    multiline: true,
    required: true,
  },
  {
    key: 'additionalContext',
    question: 'Any additional context AI should know? (optional)',
    placeholder: 'e.g., I prefer simple UI, Must work offline, Target audience is students',
    multiline: true,
    required: false,
  },
  {
    key: 'coreFeatures',
    question: 'Key features to include? (separate with commas or semicolons)',
    placeholder: 'e.g., User login; Dashboard; Export to PDF; Dark mode',
    multiline: true,
    required: true,
  },
  {
    key: 'techStack',
    question: 'Preferred tech stack? (optional - AI can suggest if unsure)',
    placeholder: 'e.g., React, Node.js, PostgreSQL — or "up to you"',
    multiline: false,
    required: false,
  },
];

// Generate AI prompt (language-agnostic template)
export function generateAIPrompt(answers: Record<string, string>): string {
  // Parse features (support comma, semicolon, or newline separators)
  const features = answers.coreFeatures
    .split(/[,;\n]/)
    .map((f: string) => f.trim())
    .filter((f: string) => f)
    .map((f: string) => `- ${f}`)
    .join('\n');

  const contextSection = answers.additionalContext
    ? `\n## Additional Context\n${answers.additionalContext}\n`
    : '';

  const techSection = answers.techStack
    ? `\n## Tech Stack Preferences\n${answers.techStack}\n`
    : '';

  return `# ${answers.projectName} — Product Development Request

## What I Want to Build
${answers.productIdea}
${contextSection}
## Key Features
${features}
${techSection}
---

Please help me build this product based on the requirements above.

1. First, review the requirements and ask if anything is unclear.
2. Propose a technical architecture.
3. Outline the implementation steps.
4. Start coding from the first step.

I'll confirm progress at each step before moving to the next.

## Documentation Rule

**Important:** Update this document (located at \`.pmpt/docs/pmpt.md\`) at these moments:
- When architecture or tech decisions are finalized
- When a feature is implemented (mark as done)
- When a development phase is completed
- When requirements change or new decisions are made

Add a "## Progress" section below and keep it updated:
\`\`\`
## Progress
- [x] Completed item
- [ ] Pending item
\`\`\`

This keeps a living record of our development journey.
`;
}

// Generate plan document
export function generatePlanDocument(answers: Record<string, string>): string {
  // Parse features (support comma, semicolon, or newline separators)
  const features = answers.coreFeatures
    .split(/[,;\n]/)
    .map((f: string) => f.trim())
    .filter((f: string) => f)
    .map((f: string) => `- [ ] ${f}`)
    .join('\n');

  const contextSection = answers.additionalContext
    ? `\n## Additional Context\n${answers.additionalContext}\n`
    : '';

  const techSection = answers.techStack
    ? `\n## Tech Stack\n${answers.techStack}\n`
    : '';

  return `# ${answers.projectName}

## Product Idea
${answers.productIdea}
${contextSection}
## Features
${features}
${techSection}
---
*Generated by pmpt plan*
`;
}

export function getPlanProgress(projectPath: string): PlanProgress | null {
  const planPath = join(getConfigDir(projectPath), PLAN_FILE);
  if (!existsSync(planPath)) return null;
  try {
    return JSON.parse(readFileSync(planPath, 'utf-8'));
  } catch {
    return null;
  }
}

export function savePlanProgress(projectPath: string, progress: PlanProgress): void {
  const configDir = getConfigDir(projectPath);
  mkdirSync(configDir, { recursive: true });
  const planPath = join(configDir, PLAN_FILE);
  progress.updatedAt = new Date().toISOString();
  writeFileSync(planPath, JSON.stringify(progress, null, 2), 'utf-8');
}

export function initPlanProgress(projectPath: string): PlanProgress {
  const progress: PlanProgress = {
    completed: false,
    startedAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };
  savePlanProgress(projectPath, progress);
  return progress;
}

export interface SavePlanResult {
  planPath: string;
  promptPath: string;
}

export function savePlanDocuments(
  projectPath: string,
  answers: Record<string, string>
): SavePlanResult {
  const pmptDir = getPmptDir(projectPath);
  mkdirSync(pmptDir, { recursive: true });

  // Save plan to pmpt folder
  const planPath = join(pmptDir, 'plan.md');
  const planContent = generatePlanDocument(answers);
  writeFileSync(planPath, planContent, 'utf-8');

  // Save AI prompt to pmpt folder
  const promptPath = join(pmptDir, 'pmpt.md');
  const promptContent = generateAIPrompt(answers);
  writeFileSync(promptPath, promptContent, 'utf-8');

  // Create initial snapshot
  createFullSnapshot(projectPath);

  return { planPath, promptPath };
}
